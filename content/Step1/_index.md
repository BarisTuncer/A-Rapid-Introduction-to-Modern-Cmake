
+++
title = "Step1: Hello CMake"
description = ""
weight = 2
+++

[Step1]:https://github.com/BarisTuncer/A-Rapid-Introduction-to-Modern-Cmake/tree/Step1
[main.c]:https://github.com/BarisTuncer/A-Rapid-Introduction-to-Modern-Cmake/blob/Step1/Driver/main.c
[Step1/CMakeLists.txt]:https://github.com/BarisTuncer/A-Rapid-Introduction-to-Modern-Cmake/blob/Step1/CMakeLists.txt
[Step1/Driver/CMakeLists.txt]:https://github.com/BarisTuncer/A-Rapid-Introduction-to-Modern-Cmake/blob/Step1/Driver/CMakeLists.txt
[Step1/Driver]:https://github.com/BarisTuncer/A-Rapid-Introduction-to-Modern-Cmake/tree/Step1/Driver

Let's switch to **[Step1]** branch.
# Hello Modern CMake

In this project we simply want to compile **[main.c]** which wants to say hello to Modern CMake.

## Global set up 

CMake starts its journey by checking the **[Step1/CMakeLists.txt]** inside the top project folder which is `NonTrivialCMakeExp` in our case.

We start by investigating this file:

* `cmake_minimum_required(VERSION 3.18)` : Sets the minimum required version of cmake for a project. You can 
check your own version of CMake by `cmake --version` in the terminal.

* `set(CMAKE_C_STANDARD 11)` : Sets the `C_STANDARD` variable to 11 for all targets

* `set(CMAKE_C_STANDARD_REQUIRED ON)` : If `CMAKE_C_STANDARD_REQUIRED` is OFF or unset, the `C_STANDARD` target property is treated 
as optional and may “decay” to a previous standard if the requested is not available.

* `project(NonTrivialCMakeExample)` : Sets the name of our project

* `add_compile_options(-Wall -Wextra)` : [**WARNING**] This is a global setting. Act for all targets in the current directory and below that are added after this command is invoked. We should keep the global settings at a minimum level.

* `add_subdirectory(Driver)` tells CMake to switch to the Driver directory and continue from the **[Step1/Driver/CMakeLists.txt]** which resides inside the **[Step1/Driver]** folder. 

## Preparing build files to compile main

Now CMake continues its journey by checking **[Step1/Driver/CMakeLists.txt]** inside the **[Step1/Driver]** folder.

We start by naming this sub-project as `driver` by declaring `project(driver)`.

The file **[main.c]** wants to say hello to Modern CMake. As you can see
adding the executable which accomplish this task is fairly simple.
We just add 

* `add_executable(main ${PROJECT_SOURCE_DIR}/main.c)` command.

`PROJECT_SOURCE_DIR` inside the Driver/CMakeLists.txt macro refers to the 
source directory for the `current` sub-project `driver` which is simply the folder `Driver` in our case.
So the executable main will be generated by the file **[main.c]**.

## Building driver

CMake is a program that produces an output. If we call it from the project directory `NonTrivialCMakeExp` then
it will produce its output into the `NonTrivialCMakeExp`. We don't want to pollute our project directory.
So we create a new directory for the output, which is generally called as `build` and let cmake to produce the output in this directory: This is called out-of-source build. 

### Simple way (on Unix environment)

Create `mkdir build`. Next `cd build` and 
finally `cmake ..`, i.e. from the `build` directory, we tell CMake to act on the parent directory `NonTrivialCMakeExp`
and produce its output inside the `build` directory. 

Now, if there was no error, `make` file is created inside the `build` directory for us. Now we can run `make`, checkout to the
`Driver` folder inside `build` and run the executable main: `./main`. 

### Ideal way (on all environments)

The approach above has an assumption that cmake will generate `make` files which is not true in Windows environment for example. In Windows cmake will generate `sln` files and to build them you need `devenv`.
So we need a more generic way which should work on all systems.

1. `cmake -B build` : produce the output into the directory `build` (if it does not exist, create it)
2. `cmake --build build`: build what is inside the `build` directory.

checkout to the `Driver` folder inside `build` and run the executable main: `./main`.


Now you are ready to go to **[Lab1](https://github.com/BarisTuncer/A-Rapid-Introduction-to-Modern-Cmake/tree/Lab1)** to get your hands dirty

You can compare your solution with the solution branch **[Sol1](https://github.com/BarisTuncer/A-Rapid-Introduction-to-Modern-Cmake/tree/Sol1)**

## cmake options

1. What does debug build mean? Run, `cmake -B build -DCMAKE_BUILD_TYPE=Debug` and `cmake --build build -v` : investigate how `main` is compiled
2. What if we want to use `ninja` instead of `make`? Try: `cmake -G "Ninja" && cd build && ninja` ( so the default behaviour is `cmake -G "Unix Makefiles"`)
3. Try also: `cmake -G "Ninja" && cmake --build build`
4. What if we want to use `clang` instead of `gcc`: Try this: `cmake -B build -D CMAKE_C_COMPILER=clang -D CMAKE_BUILD_TYPE=Release`
5. Now, `cmake --build build -v` : investigate how main is be compiled        
6. Finally, In top level CMakeLists.txt set `ENABLE_WARNINGS` option to `OFF` and try: `cmake -B build -S. -D ENABLE_WARNINGS=ON `

Congrats! At this point you know what the following command does:
```
cmake -B build -G "Ninja" -D CMAKE_C_COMPILER=clang -D CMAKE_BUILD_TYPE=Release -D ENABLE_WARNINGS=ON
cmake --build build
```

## Note:
If in a script we want to specify the source of the project use `-S` : `cmake -S path\to\source\`

For example above we could use: `cmake -S . -B build -DCMAKE_BUILD_TYPE=Debug`

In some scripts you can see `-H` flag. It is an internal option which is not documented but widely used by community and
It has been replaced with the official source directory flag of `-S`.

## Building main (on Windows)

If you are using VSCode or Visual Studio you can use plugin for CMake to generate the `main.exe` for you. 
In case you wonder how to mimic the procedure above in Windows you can:

You can simply run:
1. `cmake -B build`
2. `cmake --build build --config Debug`

OR (no need this long way actually)

1. `mkdir build` (if you want to delete already existing `build` folder: `rd /s /q build`)
2. `cd build`
3. `cmake ..` (this will generate a `sln` file inside `build`. In our case is it is called `NonTrivialCMakeExample.sln`)
4. `devenv NonTrivialCMakeExample.sln /Build` (This will create `main.exe` in `build\Debug`)

NOte: You may need to add the folder which contains `devenv` into your envronment path: In my case it is in: `C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\Common7\IDE` folder.
